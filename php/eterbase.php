<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception as Exception; // a common import

class eterbase extends Exchange {

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'id' => 'eterbase',
            'name' => 'ETERBASE',
            'countries' => array ( 'SK' ),
            'rateLimit' => 500,
            'certified' => false,
            'has' => array (
                'CORS' => false,
                'publicAPI' => true,
                'privateAPI' => true,
                'cancelOrder' => true,
                'createDepositAddress' => false,
                'createOrder' => true,
                'deposit' => false,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => false,
                'fetchOrderBook' => false,
                'fetchOrders' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchBidsAsks' => false,
                'fetchTrades' => true,
                'withdraw' => false,
            ),
            'timeframes' => array (
                '1m' => '1',
                '5m' => '5',
                '15m' => '15',
                '1h' => '60',
                '4h' => '240',
                '1d' => '1440',
                '1w' => '10080',
            ),
            'urls' => array (
                'logo' => 'https://www.eterbase.com/wp-content/uploads/2019/09/Eterbase-Logo-Horizontal-1024x208.png',
                'base' => 'https://api.eterbase.exchange',
                'api' => 'https://api.eterbase.exchange/api',
                'www' => 'https://www.eterbase.com',
                'doc' => 'https://developers.eterbase.exchange',
                'fees' => 'https://www.eterbase.com/exchange/fees',
            ),
            'api' => array (
                'public' => array (
                    'get' => array (
                        'ping',
                        'assets',
                        'markets',
                        'tickers',
                        'markets/{id}/trades',
                    ),
                ),
                'private' => array (
                    'get' => array (
                        'accounts/{id}/balances',
                        'accounts/{id}/orders',
                        'accounts/{id}/fills',
                        'orders/{id}',
                    ),
                    'post' => array (
                        'orders',
                    ),
                    'delete' => array (
                        'orders/{id}',
                    ),
                ),
            ),
            'fees' => array (
                'trading' => array (
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => 0.09,
                    'maker' => 0.09,
                ),
            ),
            'options' => array (
                'createMarketBuyOrderRequiresPrice' => true,
            ),
        ));
    }

    public function find_market ($id) {
        // need to pass identifier as string
        $idString = (string) $id;
        return parent::find_market($idString);
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $httpHeaders = null, $body = null) {
        $request = '/' . $this->implode_params($path, $params);
        $query = $this->omit ($params, $this->extract_params($path));
        if ($method === 'GET') {
            if ($query) {
                $request .= '?' . $this->urlencode ($query);
            }
        }
        $url = $this->urls['api'] . $request;
        if ($api === 'private') {
            $this->check_required_credentials();
            $payload = '';
            if ($method !== 'GET') {
                if ($query) {
                    $body = $this->json ($query);
                    $payload = $body;
                }
            }
            // construct signature
            $hasBody = ($method === 'POST') || ($method === 'PUT') || ($method === 'PATCH');
            // $date = 'Mon, 30 Sep 2019 13:57:23 GMT';
            $date = $this->rfc2616 ($this->milliseconds ());
            $urlBaselength = strlen ($this->urls['base']) - 0;
            $urlPath = mb_substr($url, $urlBaselength);
            $headersCSV = 'date' . ' ' . 'request-line';
            // eslint-disable-next-line quotes
            $message = 'date' . ':' . ' ' . $date . "\n" . $method . ' ' . $urlPath . ' HTTP/1.1';
            $digest = '';
            if ($hasBody) {
                $digest = 'SHA-256=' . $this->hash ($payload, 'sha256', 'base64');
                // eslint-disable-next-line quotes
                $message = $message . "\ndigest" . ':' . ' ' . $digest;
                $headersCSV = $headersCSV . ' ' . 'digest';
            }
            $sig = $this->hmac ($message, $this->secret, 'sha256', 'base64');
            // eslint-disable-next-line quotes
            $authorizationHeader = "hmac username=\"" . $this->apiKey . "\",algorithm=\"hmac-sha256\",headers=\"" . $headersCSV . "\",signature=\"" . $sig . "\"";
            $httpHeaders = array (
                'Date' => $date,
                'Authorization' => $authorizationHeader,
                'Content-Type' => 'application/json',
            );
            if ($hasBody) {
                $httpHeaders = array_merge ($httpHeaders, array( 'Digest' => $digest ));
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $httpHeaders );
    }

    public function parse_market ($raw) {
        $baseId = $this->safe_string($raw, 'base');
        $quoteId = $this->safe_string($raw, 'quote');
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $symbol = $base . '/' . $quote;
        $state = $this->safe_string($raw, 'state');
        $active = strtoupper($state) === 'TRADING';
        $rules = $this->safe_value($raw, 'tradingRules');
        $qtyMin = null;
        $qtyMax = null;
        $costMin = null;
        $costMax = null;
        $rule = null;
        if ($rules) {
            for ($i = 0; $i < count ($rules); $i++) {
                $rule = $rules[$i];
                $attribute = $this->safe_value($rule, 'attribute');
                $condition = $this->safe_value($rule, 'condition');
                $value = $this->safe_value($rule, 'value');
                if (($attribute === 'Qty') && ($condition === 'Min')) {
                    $qtyMin = $value;
                } else if (($attribute === 'Qty') && ($condition === 'Max')) {
                    $qtyMax = $value;
                } else if (($attribute === 'Cost') && ($condition === 'Min')) {
                    $costMin = $value;
                } else if (($attribute === 'Cost') && ($condition === 'Max')) {
                    $costMax = $value;
                }
            }
        }
        $result = array (
            'id' => $this->safe_string($raw, 'id'),
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'base' => $base,
            'quote' => $quote,
            'symbol' => $symbol,
            'active' => $active,
            'limits' => array (
                'amount' => array (
                    'min' => $qtyMin,
                    'max' => $qtyMax,
                ),
                'price' => array (
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array (
                    'min' => $costMin,
                    'max' => $costMax,
                ),
            ),
            'precision' => array (
                'price' => 8,
                'amount' => 8,
                'cost' => 8,
            ),
            'info' => $raw,
        );
        return $result;
    }

    public function fetch_markets ($params = array ()) {
        $markets = $this->publicGetMarkets ($params);
        $result = array();
        if ($markets) {
            for ($i = 0; $i < count ($markets); $i++) {
                $market = $this->parse_market ($markets[$i]);
                $result[] = $market;
            }
        }
        return $result;
    }

    public function parse_ticker ($raw) {
        $id = $this->safe_integer($raw, 'marketId');
        $market = $this->find_market($id);
        $timestamp = $this->safe_integer($raw, 'time');
        $price = $this->safe_float($raw, 'price');
        $result = array (
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'last' => $price,
            'high' => $this->safe_float($raw, 'high'),
            'low' => $this->safe_float($raw, 'low'),
            'change' => $this->safe_float($raw, 'change'),
            'baseVolume' => $this->safe_float($raw, 'volumeBase'),
            'quoteVolume' => $this->safe_float($raw, 'volume'),
            'ask' => null,
            'askVolume' => null,
            'average' => null,
            'bid' => null,
            'bidVolume' => null,
            'close' => $price,
            'open' => null,
            'percentage' => null,
            'previousClose' => null,
            'vwap' => null,
            'info' => $raw,
        );
        return $result;
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchTicker requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        $rawTickers = $this->publicGetTickers ($params);
        $raw = null;
        if ($rawTickers) {
            for ($i = 0; $i < count ($rawTickers); $i++) {
                if ($this->safe_string($rawTickers[$i], 'marketId') === $market['id']) {
                    $raw = $rawTickers[$i];
                    break;
                }
            }
        }
        $result = $this->parse_ticker($raw);
        return $result;
    }

    public function fetch_tickers ($symbols = null, $params = array ()) {
        $this->load_markets();
        $rawTickers = $this->publicGetTickers ($params);
        $result = array();
        if ($rawTickers) {
            for ($i = 0; $i < count ($rawTickers); $i++) {
                $result[] = $this->parse_ticker($rawTickers[$i]);
            }
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function parse_trade ($raw, $market) {
        $price = $this->safe_float($raw, 'price');
        $qty = $this->safe_float($raw, 'qty');
        $fee = $this->safe_float($raw, 'fee');
        $feeAsset = $this->safe_string($raw, 'feeAsset');
        $cost = $this->safe_float($raw, 'qty');
        if (!$cost) {
            $cost = (int) round($price * $qty, $market->precision.cost);
        }
        $timestamp = $this->safe_integer($raw, 'executedAt');
        if (!$timestamp) {
            $timestamp = $this->safe_integer($raw, 'filledAt');
        }
        $rawSide = $this->safe_string($raw, 'side');
        $side = $rawSide === '1' ? 'buy' : 'sell';
        $rawLiquidity = $this->safe_string($raw, 'liquidity');
        $liquidity = $rawLiquidity === '1' ? 'maker' : 'taker';
        $orderId = $this->safe_string($raw, 'orderId');
        return array (
            'symbol' => $market['symbol'],
            'id' => $this->safe_string($raw, 'id'),
            'side' => $side,
            'price' => $price,
            'amount' => $qty,
            'cost' => $cost,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'takerOrMaker' => $liquidity,
            'order' => $orderId,
            'type' => null,
            'fee' => array (
                'cost' => $fee,
                'currency' => $this->safe_currency_code($feeAsset),
            ),
            'info' => $raw,
        );
    }

    public function fetch_trades ($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array (
            'id' => $market['id'],
        );
        $response = $this->publicGetMarketsIdTrades (array_merge ($request, $params));
        return $this->parse_trades($response, $market);
    }

    public function fetch_balance ($params = array ()) {
        $this->load_markets();
        $request = array (
            'id' => $this->uid,
        );
        $rawBalances = $this->privateGetAccountsIdBalances (array_merge ($request, $params));
        $result = array( 'info' => $rawBalances );
        if ($rawBalances) {
            for ($i = 0; $i < count ($rawBalances); $i++) {
                $rawBalance = $rawBalances[$i];
                $assetId = $this->safe_string($rawBalance, 'assetId');
                $assetCode = $this->safe_currency_code($assetId);
                $account = array (
                    'free' => $this->safe_float($rawBalance, 'available'),
                    'used' => $this->safe_float($rawBalance, 'reserved'),
                    'total' => $this->safe_float($rawBalance, 'balance'),
                );
                $result[$assetCode] = $account;
            }
        }
        return $this->parse_balance($result);
    }

    public function parse_order ($raw, $market = null) {
        if ($market === null) {
            $marketId = $this->safe_integer($raw, 'marketId');
            $market = $this->find_market($marketId);
        }
        $id = $this->safe_string($raw, 'id');
        $timestamp = $this->safe_integer($raw, 'placedAt');
        $rawSide = $this->safe_string($raw, 'side');
        $side = $rawSide === '1' ? 'buy' : 'sell';
        $rawType = $this->safe_string($raw, 'type');
        $type = null;
        if ($rawType === '1') {
            $type = 'market';
        } else if ($rawType === '2') {
            $type = 'limit';
        } else if ($rawType === '3') {
            $type = 'market';
        } else {
            $type = 'limit';
        }
        $price = $this->safe_float($raw, 'limitPrice');
        $amount = $this->safe_float($raw, 'qty');
        $remaining = $this->safe_float($raw, 'remainingQty');
        $filled = $amount - $remaining;
        if ($filled > 0) {
            $filled = (int) round($filled, $market->precision.qty);
        }
        $cost = (int) round($price * $filled, $market->precision.cost);
        $rawState = $this->safe_string($raw, 'state');
        $state = strtoupper($rawState) === '4' ? 'closed' : 'open';
        if ($type === 'market') {
            if ($price === 0.0) {
                if (($cost !== null) && ($filled !== null)) {
                    if (($cost > 0) && ($filled > 0)) {
                        $price = $cost / $filled;
                    }
                }
            }
        }
        $fee = null;
        $average = null;
        if ($cost !== null) {
            if ($filled) {
                $average = (int) round($cost / $filled, $market->precision.qty);
            }
        }
        return array (
            'info' => $raw,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market->symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $state,
            'fee' => $fee,
            'trades' => null,
        );
    }

    public function fetch_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrders requires a $symbol argument');
        }
        if ($this->safe_string($params, 'state') === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrders requires a state argument');
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        $yesterdayTimestamp = $this->now () - 86400;
        $request = array (
            'id' => $this->uid,
            'marketId' => $market['id'],
            'state' => 'ACTIVE',
            'from' => $yesterdayTimestamp,
            'limit' => 10,
            'offset' => 0,
        );
        if ($since !== null) {
            $request['from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetAccountsIdOrders (array_merge ($request, $params));
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_closed_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrders requires a $symbol argument');
        }
        $orders = $this->fetch_orders($symbol, $since, $limit, array_merge (array( 'state' => 'INACTIVE' ), $params));
        return $orders;
    }

    public function fetch_open_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders requires a $symbol argument');
        }
        $orders = $this->fetch_orders($symbol, $since, $limit, array_merge (array( 'state' => 'ACTIVE' ), $params));
        return $orders;
    }

    public function fetch_my_trades ($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market ($symbol);
        $yesterdayTimestamp = $this->now () - 86400;
        $request = array (
            'id' => $this->uid,
            'marketId' => $market['id'],
            'from' => $yesterdayTimestamp,
            'limit' => 10,
            'offset' => 0,
        );
        if ($since !== null) {
            $request['from'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetAccountsIdFills (array_merge ($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function create_order ($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $uppercaseType = strtoupper($type);
        $type = null;
        if ($uppercaseType === 'MARKET') {
            $type = 1;
        } else if ($uppercaseType === 'LIMIT') {
            $type = 2;
        } else if ($uppercaseType === 'STOPMARKET') {
            $type = 3;
        } else {
            $type = 4;
        }
        $uppercaseSide = strtoupper($side);
        $side = $uppercaseSide === 'BUY' ? 1 : 2;
        $request = array (
            'accountId' => $this->uid,
            'marketId' => $market['id'],
            'type' => $type,
            'side' => $side,
        );
        if (($uppercaseType === 'MARKET') && ($uppercaseSide === 'BUY')) {
            // for $market buy it requires the $amount of quote currency to spend
            if ($this->options['createMarketBuyOrderRequiresPrice']) {
                if ($price === null) {
                    throw new InvalidOrder($this->id . " createOrder() requires the $price argument with $market buy orders to calculate total order cost ($amount to spend), where cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the $amount argument (the exchange-specific behaviour)");
                } else {
                    $amount = $amount * $price;
                }
            }
            $request['cost'] = $this->amount_to_precision($symbol, $amount);
        } else {
            $request['qty'] = $this->amount_to_precision($symbol, $amount);
        }
        if ($uppercaseType === 'LIMIT') {
            $request['limitPrice'] = $this->price_to_precision($symbol, $price);
        }
        $request['postOnly'] = false;
        $request['timeInForce'] = 'GTC';
        $response = $this->privatePostOrders (array_merge ($request, $params));
        return array (
            'id' => $this->safe_string($response, 'id'),
            'info' => $response,
        );
    }

    public function cancel_order ($id, $symbol = null, $params = array ()) {
        $request = array (
            'id' => $id,
        );
        $this->privateDeleteOrdersId (array_merge ($request, $params));
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $response = array();
        return $this->parse_order_book($response, $this->safe_integer($response, 'timestamp'));
    }
}
